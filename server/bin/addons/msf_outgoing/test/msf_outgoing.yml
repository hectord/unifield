- 
  Creating a sale.order record A
- 
  !record {model: sale.order, id: outgoing_so_A}:
    name: so a
    amount_tax: 0.0
    amount_total: 1.0
    amount_untaxed: 1.0
    company_id: base.main_company
    date_order: '2011-04-13'
    invoice_quantity: order
    order_policy: manual
    partner_id: outgoing_partner_A
    partner_invoice_id: outgoing_address_A
    partner_order_id: outgoing_address_A
    partner_shipping_id: outgoing_address_A
    picking_policy: direct
    pricelist_id: product.list0
    shop_id: sale.shop
    priority: normal
    categ: medical
- 
  Creating a sale.order.line record A1
- 
  !record {model: sale.order.line, id: outgoing_sol_A1}:
    name: sol a1
    company_id: base.main_company
    delay: 7.0
    order_id: outgoing_so_A
    price_unit: 1.0
    product_id: outgoing_product_A
    product_uom: product.product_uom_unit
    product_uom_qty: 100
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_stock
- 
  Creating a sale.order.line record A2
- 
  !record {model: sale.order.line, id: outgoing_sol_A2}:
    name: sol a2
    company_id: base.main_company
    delay: 7.0
    order_id: outgoing_so_A
    price_unit: 1.0
    product_id: outgoing_product_B
    product_uom: product.product_uom_unit
    product_uom_qty: 200
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_stock
- 
  Creating a sale.order.line record A3
- 
  !record {model: sale.order.line, id: outgoing_sol_A3}:
    name: sol a3
    company_id: base.main_company
    delay: 7.0
    order_id: outgoing_so_A
    price_unit: 1.0
    product_id: outgoing_product_C
    product_uom: product.product_uom_unit
    product_uom_qty: 300
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_stock
- 
  Creating a sale.order record B
- 
  !record {model: sale.order, id: outgoing_so_B}:
    name: so b
    amount_tax: 0.0
    amount_total: 1.0
    amount_untaxed: 1.0
    company_id: base.main_company
    date_order: '2011-04-13'
    invoice_quantity: order
    order_policy: manual
    partner_id: outgoing_partner_A
    partner_invoice_id: outgoing_address_A
    partner_order_id: outgoing_address_A
    partner_shipping_id: outgoing_address_A
    picking_policy: direct
    pricelist_id: product.list0
    shop_id: sale.shop
    priority: normal
    categ: medical
- 
  Creating a sale.order.line record B1
- 
  !record {model: sale.order.line, id: outgoing_sol_B1}:
    name: sol b1
    company_id: base.main_company
    delay: 7.0
    order_id: outgoing_so_B
    price_unit: 1.0
    product_id: outgoing_product_A
    product_uom: product.product_uom_unit
    product_uom_qty: 100
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_stock
- 
  Creating a sale.order.line record B2
- 
  !record {model: sale.order.line, id: outgoing_sol_B2}:
    name: sol b2
    company_id: base.main_company
    delay: 7.0
    order_id: outgoing_so_B
    price_unit: 1.0
    product_id: outgoing_product_B
    product_uom: product.product_uom_unit
    product_uom_qty: 200
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_stock
- 
  Creating a sale.order.line record B3
- 
  !record {model: sale.order.line, id: outgoing_sol_B3}:
    name: sol b3
    company_id: base.main_company
    delay: 7.0
    order_id: outgoing_so_B
    price_unit: 1.0
    product_id: outgoing_product_C
    product_uom: product.product_uom_unit
    product_uom_qty: 300
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_stock
-
  I load the sale order references into context
-
  !python {model: sale.order}: |
    context['so'] = {'a': ref("outgoing_so_A"),
                     'b': ref("outgoing_so_B")}
-
  I load the sale order lines references into context
-
  !python {model: sale.order}: |
    context['sol'] = {'a1': ref("outgoing_sol_A1"),
                      'a2': ref("outgoing_sol_A2"),
                      'a3': ref("outgoing_sol_A3"),
                      'b1': ref("outgoing_sol_B1"),
                      'b2': ref("outgoing_sol_B2"),
                      'b3': ref("outgoing_sol_B3")}
-
  I load the product references into context
-
  !python {model: sale.order}: |
    context['product'] = {'a': ref("outgoing_product_A"),
                          'b': ref("outgoing_product_B"),
                          'c': ref("outgoing_product_C")}
-
  I load the lot references into context
-
  !python {model: sale.order}: |
    context['lot'] = {'a': {'i': ref("outgoing_lot_Ai"),
                            's': ref("outgoing_lot_As")},
                      'b': {'i': ref("outgoing_lot_Bi"),
                            's': ref("outgoing_lot_Bs")}}
-
  I load the address reference
-
  !python {model: sale.order}: |
    context['address'] = ref("outgoing_address_A")
-
  I first validate both sale orders SOA and SOB
-
  !python {model: sale.order}: |
    import netsvc
    wf_service = netsvc.LocalService("workflow")
    wf_service.trg_validate(uid, 'sale.order', ref("outgoing_so_A"), 'order_validated', cr)
    wf_service.trg_validate(uid, 'sale.order', ref("outgoing_so_B"), 'order_validated', cr)
    wf_service.trg_validate(uid, 'sale.order', ref("outgoing_so_A"), 'order_confirm', cr)
    wf_service.trg_validate(uid, 'sale.order', ref("outgoing_so_B"), 'order_confirm', cr)
-
  I check two draft picking objects have been created
-
  !python {model: stock.picking}: |
    idsA = self.search(cr, uid, [('sale_id', '=', ref("outgoing_so_A")), ('state', '=', 'draft')], context=context)
    idsB = self.search(cr, uid, [('sale_id', '=', ref("outgoing_so_B")), ('state', '=', 'draft')], context=context)
    assert len(idsA) == 1, 'number of created draft picking for SO A is wrong, 1 - %s'%len(idsA)
    assert len(idsB) == 1, 'number of created draft picking for SO B is wrong, 1 - %s'%len(idsB)
    # set in the context
    context.update({'out':{'a':idsA, 'b': idsB}})
-
  I check the product and quantities in OUT draft picking objects
-
  !python {model: stock.picking}: |
    for obj in self.browse(cr, uid, context['out']['a']+context['out']['b'], context=context):
      for move in obj.move_lines:
        sol = move.sale_line_id
        assert move.product_id.id == sol.product_id.id, 'product in out stock move for %s is wrong - %s - %s'%(sol.name, sol.product_id.name, move.product_id.name)
        assert move.product_qty == sol.product_uom_qty, 'quantity in out stock move for %s is wrong - %s - %s'%(sol.name, sol.product_uom_qty, move.product_qty)
-
  I open the create picking wizard for A
-
  !python {model: stock.picking}: |
    idsA = context['out']['a']
    self.force_assign(cr, uid, idsA)
    res = self.create_picking(cr, uid, idsA, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check the quantity rule "integrity_check_create_picking" #1: no negative quantity
-
  !python {model: create.picking}: |
    rule = 'negative'
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        mem.write({'quantity': -6}, context=c)
    # validate the creation
    self.do_create_picking(cr, uid, ids, context=c)
    # we should get negative integrity status for each line
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # there should be no picking ticket created
    picking_ids = self.pool.get('stock.picking').search(cr, uid, [('backorder_id', 'in', context['out']['a'])], context=context)
    assert len(picking_ids) == 0, 'picking ticket should have not been created for %s rule - 0 - %s'%(rule, len(picking_ids))
-
  I check the quantity rule "integrity_check_create_picking" #2: empty picking
-
  !python {model: create.picking}: |
    rule = 'empty'
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        mem.write({'quantity': 0}, context=c)
    # validate the creation
    c.update({'yml_test': True})
    self.do_create_picking(cr, uid, ids, context=c)
    # empty picking
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # there should be no picking ticket created
    picking_ids = self.pool.get('stock.picking').search(cr, uid, [('backorder_id', 'in', context['out']['a'])], context=context)
    assert len(picking_ids) == 0, 'picking ticket should have not been created for %s rule - 0 - %s'%(rule, len(picking_ids))
-
  I check the production lot rule "integrity_check_prodlot" #3 a not lot managed product does not allow production lot
-
  !python {model: create.picking}: |
    rule = 'no_lot_needed'
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.select_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['c']:
          mem.write({'prodlot_id': context['lot']['a']['i']}, context=c)
    # validate the creation
    self.do_create_picking(cr, uid, ids, context=c)
    # no lot needed rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['c']:
          assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # there should be no picking ticket created
    picking_ids = self.pool.get('stock.picking').search(cr, uid, [('backorder_id', 'in', context['out']['a'])], context=context)
    assert len(picking_ids) == 0, 'picking ticket should have not been created for %s rule - 0 - %s'%(rule, len(picking_ids))
-
  I create a partial picking ticket 10, 20, 30 without production lots
-
  !python {model: create.picking}: |
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.select_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['a']:
          mem.write({'quantity': 10, 'prodlot_id': False}, context=c)
        if mem.product_id.id == context['product']['b']:
          mem.write({'quantity': 20, 'prodlot_id': False}, context=c)
        if mem.product_id.id == context['product']['c']:
          mem.write({'quantity': 30, 'prodlot_id': False}, context=c)
    # validate the creation
    self.do_create_picking(cr, uid, ids, context=c)
    # there should be one picking ticket created
    picking_ids = self.pool.get('stock.picking').search(cr, uid, [('backorder_id', 'in', context['out']['a'])], context=context)
    # add the picking ticket id to the context structure
    context.update({'pick': {'a': picking_ids}})
    assert len(picking_ids) == 1, 'picking ticket should have been created - 1 - %s'%(len(picking_ids))
-
  I open the validate picking wizard for A
-
  !python {model: stock.picking}: |
    idsA = context['pick']['a']
    res = self.validate_picking(cr, uid, idsA, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check the production lot rule "integrity_check_prodlot" No production lot are selected, it should fail.
  #1 a batch management product needs a standard production lot ***ONLY AT PICKING VALIDATION STAGE.
-
  !python {model: create.picking}: |
    rule = 'missing_lot'
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.select_all(cr, uid, ids, context=c)
    # validate the creation
    self.do_validate_picking(cr, uid, ids, context=c)
    # lot needed rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['a']:
          assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # there should be no ppl created
    ppl_ids = self.pool.get('stock.picking').search(cr, uid, [('previous_step_id', 'in', context['pick']['a'])], context=context)
    assert len(ppl_ids) == 0, 'ppl should have not been created for %s rule - 0 - %s'%(rule, len(ppl_ids))
-
  I check the production lot rule "integrity_check_prodlot" No production lot are selected, it should fail.
  #2 a expiry date product needs an internal production lot ***ONLY AT PICKING VALIDATION STAGE
-
  !python {model: create.picking}: |
    rule = 'missing_date'
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.select_all(cr, uid, ids, context=c)
    # validate the creation
    self.do_validate_picking(cr, uid, ids, context=c)
    # date needed rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['b']:
          assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # there should be no ppl created
    ppl_ids = self.pool.get('stock.picking').search(cr, uid, [('previous_step_id', 'in', context['pick']['a'])], context=context)
    assert len(ppl_ids) == 0, 'ppl should have not been created for %s rule - 0 - %s'%(rule, len(ppl_ids))
-
  I validate the picking
-
  !python {model: create.picking}: |
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    self.select_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['a']:
          mem.write({'prodlot_id': context['lot']['a']['s']}, context=c)
        if mem.product_id.id == context['product']['b']:
          mem.write({'prodlot_id': context['lot']['b']['i']}, context=c)
        if mem.product_id.id == context['product']['c']:
          mem.write({'prodlot_id': False}, context=c)
    # validate the creation
    self.copy_all(cr, uid, ids, context=c)
    self.do_validate_picking(cr, uid, ids, context=c)
    # there should be one ppl created
    ppl_ids = self.pool.get('stock.picking').search(cr, uid, [('previous_step_id', 'in', context['pick']['a'])], context=context)
    # add the ppl id to the context structure
    context.update({'ppl': {'a': ppl_ids}})
    assert len(ppl_ids) == 1, 'ppl should have been created - 1 - %s'%(len(ppl_ids))
-
  I open the return product wizard for A
-
  !python {model: stock.picking}: |
    idsA = context['ppl']['a']
    res = self.return_products(cr, uid, idsA, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check the production lot rule "integrity_check_return_products" set a negative value
  #1 no negative values (<0)
-
  !python {model: create.picking}: |
    rule = 'negative'
    # return products -> product_moves_returnproducts ('stock.move.memory.returnproducts')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    self.select_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_returnproducts:
        if mem.product_id.id == context['product']['c']:
          mem.write({'qty_to_return': -10}, context=c)
    # return the products
    self.do_return_products(cr, uid, ids, context=c)
    # negative value rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_returnproducts:
        if mem.product_id.id == context['product']['c']:
          assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # assert that nothing has been returned
    vals = [90, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I check the production lot rule "integrity_check_return_products" empty wizard
  #2 at least one positive one (>0)
-
  !python {model: create.picking}: |
    rule = 'empty'
    # return products -> product_moves_returnproducts ('stock.move.memory.returnproducts')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    # return the products
    self.do_return_products(cr, uid, ids, context=c)
    # empty rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_returnproducts:
        assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # assert that nothing has been returned
    vals = [90, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I check the production lot rule "integrity_check_return_products" try to return more than available
  #3 no more than available quantity
-
  !python {model: create.picking}: |
    rule = 'return_qty_too_much'
    # return products -> product_moves_returnproducts ('stock.move.memory.returnproducts')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    # I set too much for the product c
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_returnproducts:
        if mem.product_id.id == context['product']['c']:
          mem.write({'qty_to_return': 5000}, context=c)
    # return the products
    self.do_return_products(cr, uid, ids, context=c)
    # empty rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_returnproducts:
        if mem.product_id.id == context['product']['c']:
          assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
    # assert that nothing has been returned
    vals = [90, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I return 5 product A
-
  !python {model: create.picking}: |
    # return products -> product_moves_returnproducts ('stock.move.memory.returnproducts')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    # I set too much for the product c
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_returnproducts:
        if mem.product_id.id == context['product']['a']:
          mem.write({'qty_to_return': 5}, context=c)
    # return the products
    self.do_return_products(cr, uid, ids, context=c)
    # assert that 5 have been returned
    vals = [95, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I open the pack ppl wizard for A
-
  !python {model: stock.picking}: |
    idsA = context['ppl']['a']
    res = self.ppl(cr, uid, idsA, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check the sequence rules "integrity_check_sequences" (0, 1)
  # rule #1, the first from value must be equal to 1
-
  !python {model: create.picking}: |
    rule = 'missing_1'
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          mem.write({'from_pack': 0, 'to_pack': 1}, context=c)
    # validate first step
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # negative value rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          assert mem.integrity_status == rule, 'integrity status is wrong for line %s - %s - %s'%(mem.line_number, rule, mem.integrity_status)
-
  I open the split wizard for product C
-
  !python {model: create.picking}: |
    rule = 'missing_1'
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          # split the line
          res = mem.split(context=c)
          model = res['res_model']
          id = res['res_id']
          c = res['context']
          context['split'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I split the line with product C, should be 30 and I split it on 2 and 28.
-
  !python {model: split.memory.move}: |
    rule = 'missing_1'
    # split move -> split_memory_move ('split.memory.move')
    ids = context['split']['ids']
    c = context['split']['c']
    self.write(cr, uid, ids, {'quantity': 2}, context=c)
    self.split(cr, uid, ids, context=c)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #2: if from[i] == from[i-1] -> to[i] == to[i-1]
-
  !python {model: create.picking}: |
    rules = ['overlap']
    # sequences
    seqs = [(1,1),(1,2)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #2: if from[i] == from[i-1] -> to[i] == to[i-1]
-
  !python {model: create.picking}: |
    rules = ['overlap']
    # sequences
    seqs = [(1,2),(1,1)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #3: if from[i] != from[i-1] -> from[i] == to[i-1]+1
-
  !python {model: create.picking}: |
    rules = ['overlap']
    # sequences
    seqs = [(1,4),(2,4)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #3: if from[i] != from[i-1] -> from[i] == to[i-1]+1
-
  !python {model: create.picking}: |
    rules = ['overlap']
    # sequences
    seqs = [(1,4),(2,3)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #3: if from[i] != from[i-1] -> from[i] == to[i-1]+1
-
  !python {model: create.picking}: |
    rules = ['overlap']
    # sequences
    seqs = [(1,4),(2,6)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #4: to[i] >= from[i]
-
  !python {model: create.picking}: |
    rules = ['overlap','to_smaller_than_from']
    # sequences
    seqs = [(2,1),(2,6)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I check the sequence rules "integrity_check_sequences"
  # rule #3: if from[i] != from[i-1] -> from[i] == to[i-1]+1
-
  !python {model: create.picking}: |
    rules = ['gap']
    # sequences
    seqs = [(1,1),(3,3)]
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          seq = seqs.pop()
          mem.write({'from_pack': seq[0], 'to_pack': seq[1]}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    self.do_ppl1(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.integrity_status in rules:
            rules.remove(mem.integrity_status)
    # assert all rules have been reached
    assert not rules, 'all rules are not triggered - %s - %s'%([], rules)
-
  I open ppl2 wizard - for prod C, put 2 in 2,3 and 28 in 4,5. the other products are put in 1,1
-
  !python {model: create.picking}: |
    # sequences
    # ppl step1 -> product_moves_ppl ('stock.move.memory.ppl')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_ppl:
        if mem.product_id.id == context['product']['c']:
          if mem.quantity == 28:
            mem.write({'from_pack': 4, 'to_pack': 5}, context=c)
          elif mem.quantity == 2:
            mem.write({'from_pack': 2, 'to_pack': 3}, context=c)
    # validate ppl1
    self.copy_all(cr, uid, ids, context=c)
    res = self.do_ppl1(cr, uid, ids, context=c)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check the weight rules "integrity_check_weight"
  # rule #1: weight must exist if not quick flow type
-
  !python {model: create.picking}: |
    rule = 'missing_weight'
    # ppl step2 -> product_moves_families ('stock.move.memory.families')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # validate ppl2
    self.do_ppl2(cr, uid, ids, context=c)
    # check the validation results
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_families:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
-
  set weight and validate ppl2 step
-
  !python {model: create.picking}: |
    # ppl step2 -> product_moves_families ('stock.move.memory.families')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_families:
        mem.write({'weight': 10}, context=c)
    # validate ppl2
    self.do_ppl2(cr, uid, ids, context=c)
-
  I check a draft shipment has been created
-
  !python {model: shipment}: |
    ids = self.search(cr, uid, [('address_id', '=', context['address']), ('state', '=', 'draft')], context=context)
    assert len(ids) == 1, 'number of created shipment is wrong, 1 - %s'%len(ids)
    # set in the context
    context.update({'draft_shipment': ids})
-
  I bring products from SO B in quick mode into the shipment. I open the create picking wizard for B
-
  !python {model: stock.picking}: |
    idsA = context['out']['b']
    self.force_assign(cr, uid, idsA)
    res = self.create_picking(cr, uid, idsA, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I create a partial picking ticket containing all products and production lots
-
  !python {model: create.picking}: |
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.select_all(cr, uid, ids, context=c)
    # set the production lots
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['a']:
          mem.write({'prodlot_id': context['lot']['a']['s']}, context=c)
        if mem.product_id.id == context['product']['b']:
          mem.write({'prodlot_id': context['lot']['b']['i']}, context=c)
        if mem.product_id.id == context['product']['c']:
          mem.write({'prodlot_id': False}, context=c)
    # validate the creation
    self.do_create_picking(cr, uid, ids, context=c)
    # there should be one picking ticket created
    picking_ids = self.pool.get('stock.picking').search(cr, uid, [('backorder_id', 'in', context['out']['b'])], context=context)
    # add the picking ticket id to the context structure
    context.update({'pick': {'b': picking_ids}})
    assert len(picking_ids) == 1, 'picking ticket should have been created - 1bis - %s'%(len(picking_ids))
-
  I set quick mode
-
  !python {model: stock.picking}: |
    ids = context['pick']['b']
    self.write(cr, uid, ids, {'flow_type': 'quick',}, context=context)
-
  I open the validate picking wizard for B
-
  !python {model: stock.picking}: |
    ids = context['pick']['b']
    res = self.validate_picking(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I validate the picking
-
  !python {model: create.picking}: |
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    self.select_all(cr, uid, ids, context=c)
    # validate the creation
    self.copy_all(cr, uid, ids, context=c)
    self.do_validate_picking(cr, uid, ids, context=c)
    # there should be one ppl created
    ppl_ids = self.pool.get('stock.picking').search(cr, uid, [('previous_step_id', 'in', context['pick']['b'])], context=context)
    # add the ppl id to the context structure
    context.update({'ppl': {'b': ppl_ids}})
    assert len(ppl_ids) == 1, 'ppl should have been created - 1 - %s'%(len(ppl_ids))
-
  I open the return product to stock wizard
-
  !python {model: shipment}: |
    ids = context['draft_shipment']
    res = self.return_packs(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check rules from "integrity_check_packs"
  #1 no negative values (<0)
-
  !python {model: shipment.wizard}: |
    rule = 'negative'
    # return products to stock -> product_moves_shipment_returnpacks ('stock.move.memory.shipment.returnpacks')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    self.select_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacks:
        mem.write({'selected_number': -10}, context=c)
    # return the products
    self.do_return_packs(cr, uid, ids, context=c)
    # negative value rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacks:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
    # assert that nothing has been returned
    vals = [95, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
    vals = [0, 0, 0]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['b'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I check rules from "integrity_check_packs"
  #2 at least one positive one (>0)
-
  !python {model: shipment.wizard}: |
    rule = 'empty'
    # return products to stock -> product_moves_shipment_returnpacks ('stock.move.memory.shipment.returnpacks')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    # return the products
    self.do_return_packs(cr, uid, ids, context=c)
    # empty rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacks:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
    # assert that nothing has been returned
    vals = [95, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
    vals = [0, 0, 0]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['b'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I check rules from "integrity_check_packs"
   #3 no more than available quantity #packs
-
  !python {model: shipment.wizard}: |
    rule = 'return_qty_too_much'
    # return products to stock -> product_moves_shipment_returnpacks ('stock.move.memory.shipment.returnpacks')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacks:
        mem.write({'selected_number': 9999}, context=c)
    # return the products
    self.do_return_packs(cr, uid, ids, context=c)
    # too much rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacks:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
    # assert that nothing has been returned
    vals = [95, 180, 270]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
    vals = [0, 0, 0]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['b'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
    I return 1 pack for the sequence (4,5) - 1 pack 4,5 contains 14 prodC
-
  !python {model: shipment.wizard}: |
    # return products to stock -> product_moves_shipment_returnpacks ('stock.move.memory.shipment.returnpacks')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacks:
        if mem.from_pack == 4:
          mem.write({'selected_number': 1}, context=c)
    # return the products
    self.do_return_packs(cr, uid, ids, context=c)
    # assert that nothing has been returned
    vals = [95, 180, 284] # 284 because we returned 14
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['a'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
    vals = [0, 0, 0]
    for sm in self.pool.get('stock.picking').browse(cr, uid, context['out']['b'][0], context=context).move_lines:
      vals.remove(sm.product_qty)
    assert not vals, 'vals is not empty - %s'%vals
-
  I open the create shipment wizard
-
  !python {model: shipment}: |
    ids = context['draft_shipment']
    res = self.create_shipment(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check rules from "integrity_check_packs"
  #1 no negative values (<0)
-
  !python {model: shipment.wizard}: |
    rule = 'negative'
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    self.select_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_create:
        mem.write({'selected_number': -10}, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # negative value rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_create:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
    # assert that no shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 0, 'shipment should have not been created for %s rule - 0 - %s'%(rule, len(shipment_ids))
-
  I check rules from "integrity_check_packs"
  #2 at least one positive one (>0)
-
  !python {model: shipment.wizard}: |
    rule = 'empty'
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # empty rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_create:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
    # assert that no shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 0, 'shipment should have not been created for %s rule - 0 - %s'%(rule, len(shipment_ids))
-
  I check rules from "integrity_check_packs"
   #3 no more than available quantity #packs
-
  !python {model: shipment.wizard}: |
    rule = 'return_qty_too_much'
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_create:
        mem.write({'selected_number': 9999}, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # too much rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_create:
        assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
    # assert that no shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 0, 'shipment should have not been created for %s rule - 0 - %s'%(rule, len(shipment_ids))
-
    I create a shipment with  1 pack so_a 1,1, 1 pack so_b 1,1 
    # present configuration of packs
    # so_a ppl_1 1,1
    # so_a ppl_1 2,3
    # so_a ppl_1 4,4
    # so_b ppl_2 1,1
-
  !python {model: shipment.wizard}: |
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # deselect
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_create:
        if mem.sale_order_id.id == context['so']['a'] and mem.from_pack == 1:
          mem.write({'selected_number': 1}, context=c)
        if mem.sale_order_id.id == context['so']['b']:
          mem.write({'selected_number': 1}, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # assert a shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 1, 'shipment should have been created - 1 - %s'%(len(shipment_ids))
    # save shipment id
    context.update({'shipment1': shipment_ids})
-
  I open the create shipment wizard
-
  !python {model: shipment}: |
    ids = context['draft_shipment']
    res = self.create_shipment(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
    I create a second shipment with the rest 
    # present configuration of packs
    # so_a ppl_1 2,3
    # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # select all
    self.select_all(cr, uid, ids, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # assert a shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 2, 'shipment should have been created - 2 - %s'%(len(shipment_ids))
    # save shipment id - keep the max (last) id
    context.update({'shipment2': [max(shipment_ids)]})
-
  I open the return from shipment wizard for shipment2
-
  !python {model: shipment}: |
    ids = context['shipment2']
    res = self.return_packs_from_shipment(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I check rules from "integrity_check_return_packs_from_shipment" (3,2)
  #1: sfrom <= sto // integrity of selected sequence
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rule = 'to_smaller_than_from'
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          mem.write({'return_from': 3, 'return_to': 2}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment" (1,2)
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rule = 'seq_out_of_range'
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          mem.write({'return_from': 1, 'return_to': 2}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment" (0,1)
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rule = 'seq_out_of_range'
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          mem.write({'return_from': 0, 'return_to': 1}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment" (3,4)
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rule = 'seq_out_of_range'
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          mem.write({'return_from': 3, 'return_to': 4}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment" (5,6)
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rule = 'seq_out_of_range'
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          mem.write({'return_from': 5, 'return_to': 6}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status == rule, 'integrity status is wrong - %s - %s'%(rule, mem.integrity_status)
-
  I split the line so_a 2,3
-
  !python {model: shipment.wizard}: |
    rule = 'to_smaller_than_from'
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          mem.split(context=c)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['seq_out_of_range','empty']
    sequences = [(1,2),(3,3)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['seq_out_of_range','empty']
    sequences = [(0,1),(3,3)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['seq_out_of_range','empty']
    sequences = [(2,2),(3,4)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['seq_out_of_range','empty']
    sequences = [(2,2),(5,6)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['seq_out_of_range','seq_out_of_range']
    sequences = [(1,2),(3,4)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['seq_out_of_range','seq_out_of_range']
    sequences = [(0,1),(5,6)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['overlap','empty']
    sequences = [(2,2),(2,3)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['overlap','empty']
    sequences = [(2,3),(2,2)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I check rules from "integrity_check_return_packs_from_shipment"
  #2: (sfrom >= from) and (sto <= to) // in the initial range
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 2,3 (split)
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    rules = ['overlap','empty']
    sequences = [(2,3),(3,3)]
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.deselect_all(cr, uid, ids, context=c)
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          seq = sequences.pop()
          mem.write({'return_from': seq[0], 'return_to': seq[1]}, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
    # rule
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_shipment_returnpacksfromshipment:
        if mem.from_pack == 2:
          assert mem.integrity_status in rules, 'integrity status is wrong - %s - %s'%(rules, mem.integrity_status)
-
  I open the return from shipment wizard for shipment2
-
  !python {model: shipment}: |
    ids = context['shipment2']
    res = self.return_packs_from_shipment(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I return everything
-
  !python {model: shipment.wizard}: |
    # return from shipment -> product_moves_shipment_returnpacksfromshipment ('stock.move.memory.shipment.returnpacksfromshipment')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset
    self.select_all(cr, uid, ids, context=c)
    # validate
    self.do_return_packs_from_shipment(cr, uid, ids, context=c)
-
  I open the create shipment wizard
-
  !python {model: shipment}: |
    ids = context['draft_shipment']
    res = self.create_shipment(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I recreate a second shipment with the rest 
  # present configuration of packs
  # so_a ppl_1 2,3
  # so_a ppl_1 4,4
-
  !python {model: shipment.wizard}: |
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # select all
    self.select_all(cr, uid, ids, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # assert a shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 3, 'shipment should have been created - 3 - %s'%(len(shipment_ids))
    # save shipment id
    context.update({'shipment2': [max(shipment_ids)]})
-
  I validate the first shipment1
-
  !python {model: shipment}: |
    ids = context['shipment1']
    self.validate(cr, uid, ids, context=context)
    for ship in self.browse(cr,uid,ids):
        assert ship.state != 'draft', 'Shipment not validated :: Result : %s'%ship.state

-
  I check the state of both OUT objects. A should be draft, B should be done (everything has been shipped).
-
  !python {model: stock.picking}: |
    idsA = context['out']['a']
    idsB = context['out']['b']
    a_data = self.read(cr, uid, idsA, ['state'], context=context)
    assert a_data[0]['state'] == 'draft', 'the state of draft outgoing A is wrong - draft - %s'%a_data[0]['state']
    b_data = self.read(cr, uid, idsB, ['state'], context=context)
    assert b_data[0]['state'] == 'done', 'the state of draft outgoing B is wrong - done - %s'%b_data[0]['state']
-
  I check the draft shipment state, should still be draft. Shipment2 is still running.
-
  !python {model: shipment}: |
    data = self.read(cr, uid, context['draft_shipment'], ['state'], context=context)
    assert data[0]['state'] == 'draft', 'the shipment is not in the good state anymore - draft - %s'%data[0]['state']
-
  I validate the shipment2
-
  !python {model: shipment}: |
    ids = context['shipment2']
    self.validate(cr, uid, ids, context=context)
-
  I check the state of OUT object. A should still be draft.
  # A 95
  # B 180
  # C 284
-
  !python {model: stock.picking}: |
    quantities = [95,180,284]
    idsA = context['out']['a']
    a_data = self.read(cr, uid, idsA, ['state'], context=context)
    for obj in self.browse(cr, uid, idsA, context=context):
      for m in obj.move_lines:
        quantities.remove(m.product_qty)
    assert a_data[0]['state'] == 'draft', 'the state of draft outgoing A is wrong - draft - %s'%a_data[0]['state']
    assert not quantities, 'quantities from OUT A are wrong - [] - %s'%quantities
-
  I check the draft shipment state, should be done. Shipment2 is over. Some products stays \
  in the corresponding out, but the shipment is for now over.
-
  !python {model: shipment}: |
    data = self.read(cr, uid, context['draft_shipment'], ['state'], context=context)
    assert data[0]['state'] == 'done', 'the shipment is not in the good state anymore - done - %s'%data[0]['state']
-
  I bring products from SO A in quick mode into a new shipment. I open the create picking wizard for A
-
  !python {model: stock.picking}: |
    idsA = context['out']['a']
    self.force_assign(cr, uid, idsA)
    res = self.create_picking(cr, uid, idsA, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I create a partial picking ticket containing all products and production lots
-
  !python {model: create.picking}: |
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.select_all(cr, uid, ids, context=c)
    # set the production lots
    for obj in self.browse(cr, uid, ids, context=c):
      for mem in obj.product_moves_picking:
        if mem.product_id.id == context['product']['a']:
          mem.write({'prodlot_id': context['lot']['a']['s']}, context=c)
        if mem.product_id.id == context['product']['b']:
          mem.write({'prodlot_id': context['lot']['b']['i']}, context=c)
        if mem.product_id.id == context['product']['c']:
          mem.write({'prodlot_id': False}, context=c)
    # validate the creation
    self.do_create_picking(cr, uid, ids, context=c)
    # there should be one picking ticket created
    picking_ids = self.pool.get('stock.picking').search(cr, uid, [('backorder_id', 'in', context['out']['a'])], context=context)
    # add the picking ticket id to the context structure
    context.update({'pick': {'a': picking_ids}})
    assert len(picking_ids) == 2, 'picking ticket should have been created - 2 - %s'%(len(picking_ids))
-
  I set quick mode
-
  !python {model: stock.picking}: |
    ids = context['pick']['a']
    self.write(cr, uid, ids, {'flow_type': 'quick',}, context=context)
-
  I open the validate picking wizard for A
-
  !python {model: stock.picking}: |
    ids = context['pick']['a']
    res = self.validate_picking(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I validate the picking
-
  !python {model: create.picking}: |
    # create picking wizard -> product_moves_picking ('stock.move.memory.picking')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # reset the qty
    self.deselect_all(cr, uid, ids, context=c)
    self.select_all(cr, uid, ids, context=c)
    # validate the creation
    self.copy_all(cr, uid, ids, context=c)
    self.do_validate_picking(cr, uid, ids, context=c)
    # there should be one ppl created
    ppl_ids = self.pool.get('stock.picking').search(cr, uid, [('previous_step_id', 'in', context['pick']['a'])], context=context)
    # add the ppl id to the context structure
    context.update({'ppl': {'a': ppl_ids}})
    assert len(ppl_ids) == 3, 'ppl should have been created - 3 - %s'%(len(ppl_ids))
-
  I check a draft shipment has been created
-
  !python {model: shipment}: |
    ids = self.search(cr, uid, [('address_id', '=', context['address']), ('state', '=', 'draft')], context=context)
    assert len(ids) == 1, 'number of created shipment is wrong, 1 - %s'%len(ids)
    # set in the context
    context.update({'draft_shipment': ids})
-
  I open the create shipment wizard
-
  !python {model: shipment}: |
    ids = context['draft_shipment']
    res = self.create_shipment(cr, uid, ids, context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I create shipment3 with the rest
-
  !python {model: shipment.wizard}: |
    # create shipment -> product_moves_shipment_create ('stock.move.memory.shipment.create')
    ids = context['wizard']['ids']
    c = context['wizard']['c']
    # select all
    self.select_all(cr, uid, ids, context=c)
    # create shipment
    c.update({'yml_test': True})
    self.do_create_shipment(cr, uid, ids, context=c)
    # assert a shipment has been created
    shipment_ids = self.pool.get('shipment').search(cr, uid, [('parent_id', 'in', context['draft_shipment'])], context=context)
    assert len(shipment_ids) == 1, 'shipment should have been created - 1 - %s'%(len(shipment_ids))
    # save shipment id
    context.update({'shipment3': [max(shipment_ids)]})
-
  I validate the shipment3
-
  !python {model: shipment}: |
    ids = context['shipment3']
    self.validate(cr, uid, ids, context=context)
-
  I check the state of OUT object. A should be done.
-
  !python {model: stock.picking}: |
    idsA = context['out']['a']
    a_data = self.read(cr, uid, idsA, ['state'], context=context)
    assert a_data[0]['state'] == 'done', 'the state of draft outgoing A is wrong - done - %s'%a_data[0]['state']
-
  I check the draft shipment state, should be done. Shipment3 is over.
-
  !python {model: shipment}: |
    data = self.read(cr, uid, context['draft_shipment'], ['state'], context=context)
    assert data[0]['state'] == 'done', 'the shipment is not in the good state anymore - done - %s'%data[0]['state']
